# 题目思路

题目实现了一个吉他，但是也可以完全当作一道算法逆向来做，抽象出算法大概如下。

- 6组输入（u8, bool）每组 1 个数据， 0 < u8 < 8，以某种可以由状态生成6 * 24的一个(u8, bool)类型的二维数组。

- 输入几组 （u8, u8）每组最多6个输入, 来从二维数组中取出生成的 (u8, bool)

- 判断取出后每组数据间的关系，若关系符合规则（共5种），每组都可以生成 一组(u8,bool,u8)

- 最后来和程序中预置的数据进行比较，一致则输出 flag

吉他的原理会导致每种和弦的按法非常多，所以每种和弦在题目中的解非常多，所在逆完校验逻辑后进行逐组爆破的速度也是一种可行的方式。

# 无符号 Rust

众所周知 Rust 是一门比较接近底层的语言，其编译出来的代码也比较接近 C，所以在一些没有符号的 Rust binary中，完全可以将 Rust 当作一个优化开的非常大的 C 程序来分析，以及配合上动态调试追踪数据流。

与此同时再去了解一些 Rust 的语法（比如 Rust 的异常传递）就可以把它当作一个没有虚表的 cpp binary 来逆。

``` rust

fn foo() -> Result<String> {
    ...
}

fn main() {
    let _ = foo().unwarp();
}

```

此类代码一般都会在程序中出现一些

``` c
foo((__int64)&v77, (volatile signed __int32 **)ptr, (__int64)&v103);
  if ( (_QWORD)v77 )
  {
    *(_QWORD *)&v91 = *((_QWORD *)&v77 + 1);
    sub_8510(
      "called `Result::unwrap()` on an `Err` value",
      43LL,
      &v91,
      &off_53D08,
      &off_53DD8);
  }
```

这样的模式，从而可以总结出一些 rust 的传参和返回值的逻辑，必须上面的 `*v77` 就是函数的 `Error` 此时 `*(v77 + 1)` 就是异常信息，而如果`*v77` 为 0，则 `*(v77 + 1)` 就是函数的返回值

如果一些题目依赖了一些外部库，并且没有对 panic 的字符串做处理，也可以通过字符串来定位函数的大概版本。但是如何程序汇编中出现了大量的 `ud2` 汇编，大概率就是对 panic 做了特殊处理，避免报错的模块信息被编入二进制程序中。

在逆向这类高级语言过程中，由于标准库的封装，所以会有很多非常深的函数，类似 cpp 中很多层调用但只是在传递参数，并没有实际运算，这时可以暂时放弃对这类函数内部的静态分析，直接动态黑盒或根据上下文来猜测函数功能。
